From b50d7d47dd52649b25df514fc0e4c0a004881ce1 Mon Sep 17 00:00:00 2001
From: Julien Cristau <jcristau@debian.org>
Date: Thu, 5 Aug 2010 17:43:19 -0400
Subject: [PATCH] Enable low power render writes on GEN3 hardware

Ported from kernel commits 45503ded966c98e604c9667c0b458d40666b9ef3 and
944001201ca0196bcdb088129e5866a9f379d08c.
---
 src/i810_reg.h    |   64 +++++++++++++++++++++++++++++++++++++++++++++++++++++
 src/i830_driver.c |   12 ++++++++++
 2 files changed, 76 insertions(+), 0 deletions(-)

Index: xserver-xorg-video-intel/src/i810_reg.h
===================================================================
--- xserver-xorg-video-intel.orig/src/i810_reg.h
+++ xserver-xorg-video-intel/src/i810_reg.h
@@ -388,6 +388,70 @@
 #define MI_MODE		       0x209c
 #define MI_DISPLAY_POWER_DOWN  0x20e0
 #define MI_ARB_STATE           0x20e4
+#define   MI_ARB_MASK_SHIFT       16    /* shift for enable bits */
+
+/* Make render/texture TLB fetches lower priorty than associated data
+ *   fetches. This is not turned on by default
+ */
+#define   MI_ARB_RENDER_TLB_LOW_PRIORITY        (1 << 15)
+
+/* Isoch request wait on GTT enable (Display A/B/C streams).
+ * Make isoch requests stall on the TLB update. May cause
+ * display underruns (test mode only)
+ */
+#define   MI_ARB_ISOCH_WAIT_GTT                 (1 << 14)
+
+/* Block grant count for isoch requests when block count is
+ * set to a finite value.
+ */
+#define   MI_ARB_BLOCK_GRANT_MASK               (3 << 12)
+#define   MI_ARB_BLOCK_GRANT_8                  (0 << 12)       /* for 3 display planes */
+#define   MI_ARB_BLOCK_GRANT_4                  (1 << 12)       /* for 2 display planes */
+#define   MI_ARB_BLOCK_GRANT_2                  (2 << 12)       /* for 1 display plane */
+#define   MI_ARB_BLOCK_GRANT_0                  (3 << 12)       /* don't use */
+
+/* Enable render writes to complete in C2/C3/C4 power states.
+ * If this isn't enabled, render writes are prevented in low
+ * power states. That seems bad to me.
+ */
+#define   MI_ARB_C3_LP_WRITE_ENABLE             (1 << 11)
+
+/* This acknowledges an async flip immediately instead
+ * of waiting for 2TLB fetches.
+ */
+#define   MI_ARB_ASYNC_FLIP_ACK_IMMEDIATE       (1 << 10)
+
+/* Enables non-sequential data reads through arbiter
+ */
+#define   MI_ARB_DUAL_DATA_PHASE_DISABLE        (1 << 9)
+
+/* Disable FSB snooping of cacheable write cycles from binner/render
+ * command stream
+ */
+#define   MI_ARB_CACHE_SNOOP_DISABLE            (1 << 8)
+
+/* Arbiter time slice for non-isoch streams */
+#define   MI_ARB_TIME_SLICE_MASK                (7 << 5)
+#define   MI_ARB_TIME_SLICE_1                   (0 << 5)
+#define   MI_ARB_TIME_SLICE_2                   (1 << 5)
+#define   MI_ARB_TIME_SLICE_4                   (2 << 5)
+#define   MI_ARB_TIME_SLICE_6                   (3 << 5)
+#define   MI_ARB_TIME_SLICE_8                   (4 << 5)
+#define   MI_ARB_TIME_SLICE_10                  (5 << 5)
+#define   MI_ARB_TIME_SLICE_14                  (6 << 5)
+#define   MI_ARB_TIME_SLICE_16                  (7 << 5)
+
+/* Low priority grace period page size */
+#define   MI_ARB_LOW_PRIORITY_GRACE_4KB         (0 << 4)        /* default */
+#define   MI_ARB_LOW_PRIORITY_GRACE_8KB         (1 << 4)
+
+/* Disable display A/B trickle feed */
+#define   MI_ARB_DISPLAY_TRICKLE_FEED_DISABLE   (1 << 2)
+
+/* Set display plane priority */
+#define   MI_ARB_DISPLAY_PRIORITY_A_B           (0 << 0)        /* display A > display B */
+#define   MI_ARB_DISPLAY_PRIORITY_B_A           (1 << 0)        /* display B > display A */
+
 #define MI_RDRET_STATE	       0x20fc
 
 /* Start addresses for each of the primary rings:
Index: xserver-xorg-video-intel/src/i830_driver.c
===================================================================
--- xserver-xorg-video-intel.orig/src/i830_driver.c
+++ xserver-xorg-video-intel/src/i830_driver.c
@@ -3064,6 +3064,19 @@
    if (!vgaHWMapMem(pScrn))
       return FALSE;
 
+   if (IS_I915G(pI830) ||
+       IS_I915GM(pI830) ||
+       IS_I945G(pI830) ||
+       IS_I945GM(pI830) ||
+       IS_G33CLASS(pI830)) {
+       CARD32 tmp = INREG(MI_ARB_STATE);
+       if (!(tmp & MI_ARB_C3_LP_WRITE_ENABLE)) {
+           /* arb state is a masked write, so set bit + bit in mask */
+           tmp = MI_ARB_C3_LP_WRITE_ENABLE | (MI_ARB_C3_LP_WRITE_ENABLE << MI_ARB_MASK_SHIFT);
+           OUTREG(MI_ARB_STATE, tmp);
+       }
+   }
+
    i830_disable_render_standby(pScrn);
 
    DPRINTF(PFX, "assert( if(!I830EnterVT(scrnIndex, 0)) )\n");
